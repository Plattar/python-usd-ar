#usda 1.0
(
    "WARNING: THIS FILE IS GENERATED BY usdGenSchema.  DO NOT EDIT."
)

class "Preliminary_AnchoringAPI" (
    doc = """
        API schema that specifies that the prim and its children should be
        placed relative to a detected plane, image, or face.

        When applied to a prim, this API schema allows the runtime to determine
        the transform of that prim and its children independently from its
        parent transform.

        Layering

        When one or more anchorable prims are defined beneath another anchorable
        prim, each anchorable prim will be positioned independently and the
        positions of its non-anchorable children will be located relative to it.

        \\note
        Due to the independent nature of anchorable prims, it is recommended
        that each anchorable prim be placed at the top level of your content.
        This also helps make it clear that each subtree has its transform
        independently calculated by the runtime.
    """
)
{
    uniform token preliminary:anchoring:type (
        allowedTokens = ["plane", "image", "face", "none"]
        doc = """
            Defines the type of anchoring for the prim. This is a required
            property for this schema.

            plane: The content will be placed along the normal and the center of
                   the detected plane.
            image: The content will be placed along the normal and center of the
                   detected image.
            face:  The content will be placed along the normal and at the center
                   of the detected face.
            none:  The content will not be anchored. This is equivalent to not
                   applying the anchoring API schema to a prim at all.
        """
    )
    rel preliminary:imageAnchoring:referenceImage (
        doc = '''
            Specifies the kind of detected image reference the prim and its
            children should be placed relative to. This property is only active
            if the anchoring type is "image".

            \\note
            This should point to a prim with the type "ReferenceImage".
        '''
    )
    uniform token preliminary:planeAnchoring:alignment (
        allowedTokens = ["horizontal", "vertical", "any"]
        doc = '''
            Specifies the kind of detected plane the prim and its children
            should be placed relative to. This property is only active if the
            anchoring type is "plane".

            horizontal: Horizontal planes include floors, tables, ceilings, and more.
            vertical: Vertical planes include walls, doors, windows, and more.
        '''
    )
}

class Preliminary_ReferenceImage "Preliminary_ReferenceImage" (
    doc = """
        Defines an image anchoring reference, which includes the image and its
        physical width.
    """
)
{
    uniform asset image (
        doc = '''
          The image to which this prim should be placed relative to. This
          should point to an image. This property is only active if the
          anchoring type is "image".

          \\note
          In a USDZ, the only valid image types are png and jpeg (any of the
          multiple common extensions for jpeg).
      '''
    )
    uniform double physicalWidth = 0 (
        doc = '''
          Specifies the physical, real-world width, defined in centimeters to
          avoid unit changes due to composition, of the image to which this prim
          should be placed relative to. This property can be used as a reference
          for AR runtimes to determine the approximate image size to look for
          and anchor this content to. This property is only active if the
          anchoring type is "image".

          \\note
          This property is not affected by its transform hierarchy as it
          describes a physical width in the real world.

          \\note
          The height is not required because it can be determined based on the
          aspect ratio of the image.
      '''
    )
}

class Preliminary_Behavior "Preliminary_Behavior" (
    doc = "A Behavior encapsulates a set of triggers and their associated actions."
)
{
    rel actions (
        doc = """
            List of \x07 Action prims that are performed when elements of p triggers
            are executed. These actions are executed serially. @see GroupAction
        """
    )
    uniform bool exclusive = 0 (
        doc = """
            Determines whether this behavior can be executed exclusively to other
            behaviors.
            Valid values are:
            - true: If a trigger in this behavior is executed, other exclusive
            behaviors will stop performing their actions.
            - false: Other actions in other behaviors can run concurrently
            with this behavior. (Default)
        """
    )
    rel triggers (
        doc = """
            List of \x07 Trigger prims that will execute the list of p actions.
        """
    )
}

class "Preliminary_Trigger" (
    doc = """A Trigger represents an event that when executed, causes an *action*
    to be performed.
    Triggers can be executed by:
      - User input: e.g. a tap gesture
      - Scene state: e.g. proximity to the camera
      - Programmatically: e.g. as a result of application state or other event
    This is the base class for all Behavior triggers.
    """
)
{
    uniform token info:id (
        doc = """The id is the identifier for the type or purpose of the trigger.
        E.g. TapGesture, ProximityToCamera
        The value of this id is interpreted by the runtime implementation of the
        behavior system.
        """
    )
}

class "Preliminary_Action" (
    doc = """An Action is performed when a *Trigger* is executed.
    Performing an action is how a Behavior modifies the state of the scene dynamically.
    For example, an action might start an animation playing, change the transform
    of an *Xformable*, or start looping audio.

    This is the base class for Behavior actions"""
)
{
    uniform token info:id (
        doc = """The id is the identifier for the type or purpose of the action.
        E.g. Impulse, Group
        The value of this id is interpreted by the runtime implementation of the
        behavior system.
        """
    )
    uniform token multiplePerformOperation = "ignore" (
        allowedTokens = ["ignore", "allow", "stop"]
        doc = """Defines how this action handles a request be performed again while
            already running.
            Valid values are:
            - allow: Perform the action again, effectively restarting it.
            - ignore: Ignore the perform request, and continue running the current action.
            - stop: Stops the current action.
        """
    )
}

class Preliminary_Text "Preliminary_Text" (
    doc = "Defines 3D extruded text geometry in the scene"
)
{
    string content = "" (
        doc = """
            Text contents. This string may include line breaks which will be honored.
        """
    )
    float depth = 0 (
        doc = """
            Extrusion depth (Z) in scene units. Must be non-negative. The geometry is visible from
            both sides even for a zero extrusion depth.
        """
    )
    uniform bool doubleSided = 0 (
        doc = """Although some renderers treat all parametric or polygonal
        surfaces as if they were effectively laminae with outward-facing
        normals on both sides, some renderers derive significant optimizations
        by considering these surfaces to have only a single outward side,
        typically determined by control-point winding order and/or 
        orientation.  By doing so they can perform \"backface culling\" to
        avoid drawing the many polygons of most closed surfaces that face away
        from the viewer.
        
        However, it is often advantageous to model thin objects such as paper
        and cloth as single, open surfaces that must be viewable from both
        sides, always.  Setting a gprim's doubleSided attribute to 
        \\c true instructs all renderers to disable optimizations such as
        backface culling for the gprim, and attempt (not all renderers are able
        to do so, but the USD reference GL renderer always will) to provide
        forward-facing normals on each side of the surface for lighting
        calculations."""
    )
    float3[] extent (
        doc = """Extent is a three dimensional range measuring the geometric
        extent of the authored gprim in its own local space (i.e. its own
        transform not applied), without accounting for any shader-induced
        displacement.  Whenever any geometry-affecting attribute is authored
        for any gprim in a layer, extent must also be authored at the same
        timesample; failure to do so will result in incorrect bounds-computation.
        \\sa \\ref UsdGeom_Boundable_Extent.
        
        An authored extent on a prim which has children is expected to include
        the extent of all children, as they will be pruned from BBox computation
        during traversal."""
    )
    string[] font (
        doc = """
            An array of font names. They will be traversed in order and the first one that matches an
            available font will be used. If no font matches exactly the behavior is undefined, although
            there may be some attempt to find a related font. The font name string contains the family
            and any styling attributes.
        """
    )
    float height (
        doc = """
            Height (Y) of the text bounding rectangle in scene units. Must be positive. Is ignored
            if wrapMode is set to singleLine.
        """
    )
    token horizontalAlignment = "center" (
        allowedTokens = ["left", "center", "right", "justified"]
        doc = """
            Placement of each line relative to the bounding rectangle.
            left: Left-align each line
            center: Center-align each line
            right: Right-align each line
            justified: Left-align each line, and add spacing between words to right-align also, if possible
        """
    )
    uniform token orientation = "rightHanded" (
        allowedTokens = ["rightHanded", "leftHanded"]
        doc = """Orientation specifies whether the gprim's surface normal 
        should be computed using the right hand rule, or the left hand rule.
        Please see for a deeper explanation and
        generalization of orientation to composed scenes with transformation
        hierarchies."""
    )
    float pointSize = 144 (
        doc = """
            Font size in points.
        """
    )
    color3f[] primvars:displayColor (
        doc = '''It is useful to have an "official" colorSet that can be used
        as a display or modeling color, even in the absence of any specified
        shader for a gprim.  DisplayColor serves this role; because it is a
        UsdGeomPrimvar, it can also be used as a gprim override for any shader
        that consumes a displayColor parameter.'''
    )
    float[] primvars:displayOpacity (
        doc = """Companion to displayColor that specifies opacity, broken
        out as an independent attribute rather than an rgba color, both so that
        each can be independently overridden, and because shaders rarely consume
        rgba parameters."""
    )
    rel proxyPrim (
        doc = '''The proxyPrim relationship allows us to link a
        prim whose purpose is "render" to its (single target)
        purpose="proxy" prim.  This is entirely optional, but can be
        useful in several scenarios:
        
        - In a pipeline that does pruning (for complexity management)
        by deactivating prims composed from asset references, when we
        deactivate a purpose="render" prim, we will be able to discover
        and additionally deactivate its associated purpose="proxy" prim,
        so that preview renders reflect the pruning accurately.
        
        - DCC importers may be able to make more aggressive optimizations
        for interactive processing and display if they can discover the proxy
        for a given render prim.
        
        - With a little more work, a Hydra-based application will be able
        to map a picked proxy prim back to its render geometry for selection.

        \\note It is only valid to author the proxyPrim relationship on
        prims whose purpose is "render".'''
    )
    uniform token purpose = "default" (
        allowedTokens = ["default", "render", "proxy", "guide"]
        doc = """Purpose is a classification of geometry into categories that 
        can each be independently included or excluded from traversals of prims 
        on a stage, such as rendering or bounding-box computation traversals.

        See for more detail about how 
        purpose is computed and used."""
    )
    token verticalAlignment = "middle" (
        allowedTokens = ["top", "middle", "lowerMiddle", "baseline", "bottom"]
        doc = """
            Vertical placement of the text.
            For a single line the alignment is relative to font features:
                top: ascender
                middle: center of capital letters
                lowerMiddle: center of lowercase letters
                baseline: baseline
                bottom: descender
            For multi-line text the alignment is relative to the bounds:
                top: lines aligned with the top
                middle, lowerMiddle: lines together with equal space above and below
                baseline, bottom: lines aligned with the bottom
        """
    )
    token visibility = "inherited" (
        allowedTokens = ["inherited", "invisible"]
        doc = '''Visibility is meant to be the simplest form of "pruning" 
        visibility that is supported by most DCC apps.  Visibility is 
        animatable, allowing a sub-tree of geometry to be present for some 
        segment of a shot, and absent from others; unlike the action of 
        deactivating geometry prims, invisible geometry is still 
        available for inspection, for positioning, for defining volumes, etc.'''
    )
    float width (
        doc = """
            Width (X) of the text bounding rectangle in scene units. Must be positive. Is ignored
            if wrapMode is set to singleLine.
        """
    )
    token wrapMode = "flowing" (
        allowedTokens = ["singleLine", "hardBreaks", "flowing"]
        doc = """
            Hint about the intent of the text flow.
            singleLine: The entire content is a single line
            hardBreaks: The content contains line breaks and no other line breaking is allowed
            flowing: The content can flow in the bounds by adding line breaks
        """
    )
    uniform token[] xformOpOrder (
        doc = """Encodes the sequence of transformation operations in the
        order in which they should be pushed onto a transform stack while
        visiting a UsdStage's prims in a graph traversal that will effect
        the desired positioning for this prim and its descendant prims.
        
        You should rarely, if ever, need to manipulate this attribute directly.
        It is managed by the AddXformOp(), SetResetXformStack(), and
        SetXformOpOrder(), and consulted by GetOrderedXformOps() and
        GetLocalTransformation()."""
    )
}

